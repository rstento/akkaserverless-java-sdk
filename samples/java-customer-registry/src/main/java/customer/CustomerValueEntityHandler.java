/*
 * Copyright 2021 Lightbend Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package customer;

import com.akkaserverless.javasdk.impl.AnySupport;
import com.akkaserverless.javasdk.impl.EntityExceptions;
import com.akkaserverless.javasdk.impl.valueentity.AdaptedCommandContext;
import com.akkaserverless.javasdk.lowlevel.ValueEntityHandler;
import com.akkaserverless.javasdk.valueentity.CommandContext;
import com.akkaserverless.javasdk.valueentity.ValueEntityBase;
import com.google.protobuf.Any;
import com.google.protobuf.Descriptors;
import com.google.protobuf.GeneratedMessageV3;
import customer.api.CustomerApi;
import customer.domain.CustomerDomain;
import scala.None$;
import scala.Option;
import scalapb.UnknownFieldSet;

/**
 * This class would be generated by codegen and should be treated mostly as an implementation detail
 * by the user.
 */
public class CustomerValueEntityHandler implements ValueEntityHandler {
  final CustomerValueEntity entity;
  final AnySupport anySupport;

  public static final Descriptors.ServiceDescriptor serviceDescriptor =
      CustomerApi.getDescriptor().findServiceByName("CustomerService");
  public static final String entityType = "customers";

  CustomerValueEntityHandler(CustomerValueEntity entity) {
    this.entity = entity;
    this.anySupport =
        new AnySupport(
            new Descriptors.FileDescriptor[] {CustomerDomain.getDescriptor()},
            CustomerValueEntityHandler.class.getClassLoader(),
            AnySupport.DefaultTypeUrlPrefix(),
            AnySupport.PREFER_JAVA());
  }

  @Override
  public ValueEntityBase.Effect<? extends GeneratedMessageV3> handleCommand(
      Any command, Any state, CommandContext<Any> context) throws Throwable {

    AdaptedCommandContext<CustomerDomain.CustomerState> adaptedContext =
        new AdaptedCommandContext(context, anySupport);

    CustomerDomain.CustomerState parsedState =
        CustomerDomain.CustomerState.parseFrom(state.getValue());

    switch (context.commandName()) {
      case "Create":
        return entity.create(
            // TODO we used to support any 'Jsonable' class here as well, parsing them with Jackson,
            // and also ScalaPB classes.
            // are we OK with restriction ourselves to actual Java protobuf classes?
            CustomerApi.Customer.parseFrom(command.getValue()), parsedState, adaptedContext);
      case "ChangeName":
        return entity.changeName(
            CustomerApi.ChangeNameRequest.parseFrom(command.getValue()),
            parsedState,
            adaptedContext);
      case "GetCustomer":
        return entity.getCustomer(
            CustomerApi.GetCustomerRequest.parseFrom(command.getValue()),
            parsedState,
            adaptedContext);
      default:
        Option<?> noneOption = None$.MODULE$;
        throw new EntityExceptions.EntityException(
            context.entityId(),
            context.commandId(),
            context.commandName(),
            "No command handler found for command ["
                + context.commandName()
                + "] on "
                + entity.getClass().toString(),
            (Option<Throwable>) noneOption);
    }
  }

  @Override
  public com.google.protobuf.any.Any emptyState() {
    return com.google.protobuf.any.Any.apply(
        AnySupport.DefaultTypeUrlPrefix()
            + "/"
            + CustomerDomain.CustomerState.getDescriptor().getFullName(),
        entity.emptyState().toByteString(),
        UnknownFieldSet.empty());
  }

  public ValueEntityBase.Effect<? extends GeneratedMessageV3> invoke(
      Any command,
      CustomerDomain.CustomerState state,
      CommandContext<CustomerDomain.CustomerState> context)
      throws Throwable {
    switch (context.commandName()) {
      case "Create":
        return entity.create(
            // TODO we used to support any 'Jsonable' class here as well, parsing them with Jackson,
            // and also ScalaPB classes.
            // are we OK with restriction ourselves to actual Java protobuf classes?
            CustomerApi.Customer.parseFrom(command.getValue()), state, context);
      case "ChangeName":
        return entity.changeName(
            CustomerApi.ChangeNameRequest.parseFrom(command.getValue()), state, context);
      case "GetCustomer":
        return entity.getCustomer(
            CustomerApi.GetCustomerRequest.parseFrom(command.getValue()), state, context);
      default:
        Option<?> noneOption = None$.MODULE$;
        throw new EntityExceptions.EntityException(
            context.entityId(),
            context.commandId(),
            context.commandName(),
            "No command handler found for command ["
                + context.commandName()
                + "] on "
                + entity.getClass().toString(),
            (Option<Throwable>) noneOption);
    }
  }
}
